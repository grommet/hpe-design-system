(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6428],{5368:(e,n,s)=>{(window.__NEXT_P=window.__NEXT_P||[]).push(["/design-tokens/using-design-tokens-in-code",function(){return s(22711)}])},22711:(e,n,s)=>{"use strict";s.r(n),s.d(n,{default:()=>i});var o=s(62021),t=s(70889);function r(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{children:"Using tokens with Grommet"}),"\n",(0,o.jsx)(n.p,{children:'There is no need to install "hpe-design-tokens" or change how you build with Grommet. The HPE Design System team has mapped "hpe-design-tokens" into "grommet-theme-hpe", so there should be no change to your workflow.'}),"\n",(0,o.jsx)(n.h2,{children:"Using tokens in non-Grommet projects"}),"\n",(0,o.jsx)(n.h3,{children:"Install hpe-design-tokens"}),"\n",(0,o.jsx)(n.p,{children:"Run the following command to add HPE design tokens to your project."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"yarn add hpe-design-tokens\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"pnpm add hpe-design-tokens\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"npm install hpe-design-tokens\n"})}),"\n",(0,o.jsx)(n.h3,{children:"Apply tokens"}),"\n",(0,o.jsx)(n.p,{children:"HPE Design Tokens are exported in a variety of formats to support teams across tech stacks. The currently supported formats are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"CSS variables"}),"\n",(0,o.jsx)(n.li,{children:"ESM"}),"\n",(0,o.jsx)(n.li,{children:"CommonJS"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["If the exports from ",(0,o.jsx)(n.code,{children:"hpe-design-tokens"})," do not meet the needs of your team, please reach out to our team in ",(0,o.jsx)(n.code,{children:"#hpe-design-system"})," in Slack."]}),"\n",(0,o.jsx)(n.h4,{children:"CSS variables"}),"\n",(0,o.jsx)(n.p,{children:"To use hpe-design-tokens as CSS variables, first import the CSS files into your project. How these files are imported will depend on your tech stack."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// For example, main.jsx\nimport 'hpe-design-tokens/dist/css/primitives.css';\nimport 'hpe-design-tokens/dist/css/color.light.css';\nimport 'hpe-design-tokens/dist/css/color.dark.css';\nimport 'hpe-design-tokens/dist/css/global.css';\nimport 'hpe-design-tokens/dist/css/components.css';\nimport 'hpe-design-tokens/dist/css/dimension.css';\nimport 'hpe-design-tokens/dist/css/dimension.small.css';\n"})}),"\n",(0,o.jsx)(n.p,{children:"Then, apply the token directly to a CSS property, or create your own CSS variable that can be modified across states."}),"\n",(0,o.jsxs)(n.p,{children:["To programmatically build up CSS classes, see ",(0,o.jsx)(n.a,{href:"#generate-css-class-names",children:"Generate CSS class names"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// For example, styles.css\n\n.hpe-button-primary {\n    --button-primary-background: var(--hpe-button-primary-rest-background);\n    background: var(--button-primary-background);\n}\n.hpe-button-primary:hover {\n    --button-primary-background: var(--hpe-button-primary-hover-background);\n}\n.hpe-button-primary:disabled {\n    --button-primary-background: var(--hpe-button-primary-disabled-rest-background);\n}\n"})}),"\n",(0,o.jsx)(n.h4,{children:"ESM"}),"\n",(0,o.jsx)(n.p,{children:"To use hpe-design-tokens as ESM, import the modules into your project. This format is intended to be used in conjunction with the CSS files."}),"\n",(0,o.jsx)(n.p,{children:"The values returned are the CSS variable for each design token."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// For example, main.jsx\nimport { light, dark, dimension, small, global, components } from 'hpe-design-tokens';\n\nconst theme = {\n    button: {\n        primary: {\n            background: components.hpe.button.primary.rest.background, // var(--hpe-button-primary-rest-background)\n        }\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{children:"CommonJS"}),"\n",(0,o.jsx)(n.p,{children:"To use hpe-design-tokens with CommonJS, import the modules into your project. This format is intended to be used in conjunction with the CSS files."}),"\n",(0,o.jsx)(n.p,{children:"The values returned are the CSS variable for each design token."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'const { light, dark, dimension, small, global, components } = require("hpe-design-tokens");\n\nconst theme = {\n    button: {\n        primary: {\n            background: components.hpe.button.primary.rest.background, // var(--hpe-button-primary-rest-background)\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{children:"Theme modes"}),"\n",(0,o.jsxs)(n.p,{children:["Building with ",(0,o.jsx)(n.a,{href:"/design-tokens/overview#semantic-tokens",children:"semantic design tokens"})," allows theme modes, such as light and dark, to be easily applied to an application or, when appropriate, a subsection of a page."]}),"\n",(0,o.jsx)(n.p,{children:"The supported theme modes are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"light"}),"\n",(0,o.jsx)(n.li,{children:"dark"}),"\n",(0,o.jsx)(n.li,{children:"auto (responsive to user's operating system preference)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Light mode is the default theme mode. To apply light mode, no additional steps are needed."}),"\n",(0,o.jsx)(n.p,{children:"To apply dark mode:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Import the ",(0,o.jsx)(n.a,{href:"#css-variables",children:"dark mode CSS file"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Apply ",(0,o.jsx)(n.code,{children:'data-mode="dark"'})," to the ",(0,o.jsx)(n.code,{children:"html"})," tag of the application or to a subsection."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'<html data-mode="dark">\n    ...\n</html>\n'})}),"\n",(0,o.jsx)(n.p,{children:"or, to apply to a subsection of the page:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'<html>\n    <body>\n      <div>\n        {/* some content */}\n      </div>\n      <div data-mode="dark">\n        {/* content to be presented in dark mode */}\n      </div>\n    </body>\n</html>\n'})}),"\n",(0,o.jsx)(n.p,{children:"To apply auto mode:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Import the ",(0,o.jsx)(n.a,{href:"#css-variables",children:"CSS color files"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["Apply ",(0,o.jsx)(n.code,{children:'data-mode="auto"'})," to the ",(0,o.jsx)(n.code,{children:"html"})," or root tag of the application."]}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'<html data-mode="auto">\n    ...\n</html>\n'})}),"\n",(0,o.jsx)(n.h3,{children:"Generate CSS class names"}),"\n",(0,o.jsxs)(n.p,{children:["This code snippet provides a starting point for how to programmatically generate CSS class names for components using either the ",(0,o.jsx)(n.a,{href:"#esm",children:"ESM"})," or ",(0,o.jsx)(n.a,{href:"#commonjs",children:"CommonJS"})," outputs."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'\n// Step 1: Import components from hpe-design-tokens\nimport { components } from "hpe-design-tokens";\n\n// Step 2: Create map of token properties to CSS properties.\n// Most token properties align to CSS properties,\n// but there are a few exceptions.\nconst tokenToCssPropertyMap = {\n  textColor: "color",\n  iconColor: "stroke",\n  textToElementX: "gap",\n  textToIconX: "gap",\n  paddingX: "padding-inline",\n  paddingY: "padding-block",\n  gapX: "row-gap",\n  gapY: "column-gap",\n  size: ["width", "height"],\n  // ... this is a demo, there may be a few others to map\n};\n\n// Helper function to create empty nested object for each class name\nconst createNestedObject = (className, obj) => {\n  if (!(className in obj)) {\n    [className].reduce(function (o, s) {\n      return (o[s] = {});\n    }, obj);\n  }\n};\n\n// Step 3: Recursively loop through component tokens to build\n// up classes for each component variant/size/state.\nconst generateComponentClasses = (obj, keyPath = []) => {\n  const flattened = {};\n\n  Object.keys(obj).forEach(key => {\n    const value = obj[key];\n\n    if (typeof value === "object" && value !== null && !Array.isArray(value)) {\n      Object.assign(flattened, generateComponentClasses(value, [...keyPath, key]));\n    } else {\n      // removing "rest" from className which refers to "resting" state of a component\n      // it\'s part of token name for consistency across the taxonomy, but not necessary\n      // for the CSS className.\n      let className = `.${keyPath.filter(k => k !== "rest").join("-")}`;\n      // converting certain states names to CSS pseudo classes\n      if (className.includes("-hover")) className = className.replace("-hover", ":hover");\n      else if (className.includes("-disabled")) className = className.replace("-disabled", ":disabled");\n\n      // treat element "paddingX", "textToElementX", "textToIconX" tokens (hpe.element.medium.paddingX.narrow) like utility classes\n      if ((keyPath.includes("element") && keyPath.includes("paddingX")) || key.includes("textToElementX") || key.includes("textToIconX")) {\n        className = `${className}-${key}`;\n        createNestedObject(className, flattened);\n        flattened[className][keyPath.includes("paddingX") ? tokenToCssPropertyMap["paddingX"] : tokenToCssPropertyMap[key] || key] = value;\n      } else {\n        createNestedObject(className, flattened);\n        // loop through as array for things like "size" which should apply to height and width\n        const properties = Array.isArray(tokenToCssPropertyMap[key]) ? tokenToCssPropertyMap[key] : [tokenToCssPropertyMap[key] || key];\n        properties.forEach(property => {\n          flattened[className][property] = value;\n        });\n      }\n    }\n  });\n\n  return flattened;\n};\n\n// Step 4: Use a script/package to convert output to CSS file.\n// Output example:\n// {\n//     ".hpe-button-primary": {\n//         background: "var(--hpe-button-primary-rest-background)",\n//         borderColor: "var(--hpe-button-primary-rest-borderColor)",\n//         color: "var(--hpe-button-primary-rest-textColor)",\n//         // ...\n//     },\n//     ".hpe-button-primary:hover": {\n//         background: "var(--hpe-button-primary-hover-background)",\n//         borderColor: "var(--hpe-button-primary-hover-borderColor)",\n//         color: "var(--hpe-button-primary-hover-textColor)",\n//         // ...\n//     },\n//     ".hpe-button-primary-medium": {\n//         fontSize: "var(--hpe-button-primary-medium-fontSize)",\n//         lineHeight: "var(--hpe-button-primary-medium-lineHeight)",\n//         borderRadius: "var(--hpe-button-primary-medium-borderRadius)",\n//         // ...\n//     },\n//     // ...\n// }\n'})})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(r,{...e})}):r(e)}}},e=>{e.O(0,[636,6593,8792],()=>e(e.s=5368)),_N_E=e.O()}]);